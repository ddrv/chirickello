Долго возился с кафкой, но в итоге прикрутил! Не всё успел накодить, но распишу как собираюсь делать:

 - [x] Сделал отдельным пакетом schema-registry для ивентов (на базе json-schema), описал в ней все ивенты, которые используются в системе
 - [x] Реализовал обработку ошибок:
    Если во время обработки события происходит ошибка, то создаётся новое событие event.failed с данными 
    - payload (json-закодированное сломавшееся событие)
    - reason (сообщение ошибки)
    - attempt (номер попытки обработать событие)
    По attempt определяется количество секунд, через которое нужно повторить попытку (определяется по Фибоначчи по номеру попытки). Если с прошлого раза изменился reason, скидываем attempt до 1 
    Это новое событие кидается во внутреннюю очередь (реализовано через БД), которую слушает отдельный консьюмер. Он-то и пытается периодически ретраить.

 - [ ] Миграция на новое событие:
    - Добавляем новую версию события в нужные сервисы, а так же опишу её в registry;
    - Деплоим либу registry;
    - Обновляем в сервисах версию либы registry;
    - Учим все консьюмеры обрабатывать эту версию события;
    - Деплоим приложение;
    - Теперь учим все продьюсеры работать с новой версией события и переключаемся на неё;
    - Снова деплоим;
    - Ждём, когда консьюмеры дочитают все ивенты старой версии;
    - Убеждаемся, что ивенты старой версии не прилетят
    - Ещё раз убеждаемся и перепроверяем;
    - Удаляем работу со старой версией в продьюсерах и консьюмерах;
    - А вот в registry оставляем. Вдруг у нас кафка и в ней никогда ничего не удаляется. А потом нам понадобится ещё один сервис и он должен будет уметь работать со всеми версиями события.

Как-то так...

То, что уже реализовано, можно посмотреть в ветке `accounting/init`, но там бойлерплейт...
